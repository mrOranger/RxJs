# Time dimension in RxJs

Time is an invisible dimension in programming and working with asynchronous code is always tricky expecilly in JavaScript, however, RxJs ables us to treat time an additional dimension of our data source, and then treat asynchronous code like synchronous one, in other terms we are able to serialize operations so that we can execute tasks only after the completition of another one.

## `interval` and `timer` factories

`setInterval` and `setTimeout` are asynchronous JavaScript's function that trigger the callback function parameter each time in a fixed interval represeted by the second parameter in the former and once after the time indicated by the second parameter in the latter. In RxJs there are two similar factory functions that emulates these behaviours, `interval` and `timer`.

Let's start with `interval` and let's examine this piece of code:

```typescript
const intervalObs = interval(1000);
```

up to this point we created a new Observable named `intervalObs` who emits integer values, starting from 1, each 1000ms (=1s) for the rest of the program's execution. Notice that a behaviour like this, emitting values without an ending point, can be achieved without resource's waisting because no Observer is attached to the Observable, that is, no value is emitted yet.

The `interval` method is show in the current figure:

<p align="center">
    <img src="../assets/4. Time/Interval.png" alt="Interval Operator" style="width:100%">
</p>

as you can see after given an input value `t` each `t` seconds a new value is produced and flows out from the pipe to the Observer in the same time interval.

The other common method whose logic is more close to an Observable respect to the `interval` is `timer`. Just like the `setTimeout` function in JavaScript, `timer` triggers an event after that the amout of input time is passed, just like the figure below:

<p align="center">
    <img src="../assets/4. Time/Timer.png" alt="Timer Operator" style="width:100%">
</p>

Now, the question is, why should we use `interval` and `timer` insted of `setInterval` and `setTimeout` that behaves exactly in the same way? The answer is that while JavaScript needs that the allocated resources should be released, RxJs does it authomatically, moreover, `setTimeout` and `setInterval` are callbacks requiring some values outside from then, therefore are not pure functions, while the corresponding methods in RxJs are pure functions.

## Delay the emission of a value

Up to this point we saw operators that emits values after a certain amout of time, or in a certan interval and the global emission time of the values is not affected, however, there the `delay` operator shifts the emission time of values for the given amout of milliseconds, just like shown in the figure for the `timer` method.

Now, applying the `delay` operator to the Observer generated by the `interval` method, is the emission of each value shifted? The answer is no, `delay` shifts only the starting emission that, therefore, only the emission of the first value is affected while the others no. It's important to notice that it is not affected the generation of the values, these are still generated once an Observer is attached, what is affected is the <u>propagation of the values through the stream</u>.

The last statement leads us to understand one of the core feature of Reactive Programming, that is operators are do not know who is the Observable and what will produce, for this reason value's generation process cannot be shifted, but only the emission process is affected.

Let's have a look to this example:

```typescript
from([1, 2, 3, 4, 5])
      .pipe(
            delay(1000),
            map((value) => value + 1),
            delay(1000),
            map((value) => value + 1),
      )
      .subscribe({
            next: (value) => console.log(value),
            complete: () => console.log('complete'),
      });
```

if you expecting that values are printed with a distance of 2s you are wrong. Operators are executed in sequence meaning and do not affects the value's generation process, therefore the array `[1, 2, 3, 4, 5]` is one value's container emitted once, after the emission of these values the entire array flows through the pipe and the observation of these values is shifted to 1s that each one of these are incremented, then shifted of 1s and incremented and finally are observed by the Observer.

## Hanlding dynamic inputs with `debounce` and `throttle`

Sometimes we have to deal with sources emitting many input values, so that we are not interested in handling all the events but just few of them. Let's consider an user's mouse input event, each time user uses the pointer, a new event is emitted, most of the times such events are so many and maybe we are interested in handling pointer's events for a specific component of our webpage.

`debounce` consists in filtering values emitted only after a certain amount of time is passed from the emission of the previous value. In software terms, **deboucing** means _executes something only after a certain period is passed without anything has been done_. I know that this operator is quite difficult to understand, however, let's consider the following figure:

<p align="center">
    <img src="../assets/4. Time/Debounce.png" alt="Debounce Operator" style="width:100%">
</p>

the source is emitting some values represeted by squares, circles and diamonds, therefore, the source is not emitting single values types. However, as you can see, differently from the other diagrams, values are not emitted with the same time rate, some values are emitted with a smaller distance from the previous while others are delayed. In this context, `debounce` is a filter, it checks that a certain amout of time, that is `t` is passed from the emission of the last value, if the amount of time is smaller than the input value, the current value is ignored, otherwise, it can reach the Observer.

Let's see the this example:

```typescript
interval(1000)
      .pipe(debounceTime(2000))
      .subscribe({
            next: (value) => console.log(value),
      });
```

nothing will be printed, because each 1s a new value is emitted, while `debounceTime` is waiting for values that are emitted after 2s, on the other hand, if we switch the timing values between `interval` and `debounce`, numbers will be printed to the console each 2s.

Up to this time, in which context this operator can be used and is effectively useful? If you are implementing a searching box where each time the user writes something making sense makes an HTTP call, you can't make a call for each character of the search string, since it is probably that the user will type something wrong and than deletes the input string to write it again. `debounce` is our solution, because we can use this operator to get strings that are emitted only from 1s from the others, meaning that the user stops typing.

`throttle` is a sort of filter like `debouce`, the difference is that takes a value and delays its emission using the time value passed as input to the function, then other values that are emitted in the time range between value's emission and observation are ignored. The following figure will probably clarify each doubt:

<p align="center">
    <img src="../assets/4. Time/Throttle.png" alt="Throttle Operator" style="width:100%">
</p>

as you can see, once the orange circle is emitted from the source, its observation is delayed of `t`, however between the emission and observation, a red circle is emitted but it will ignored because `throttle` will filter it. After `t` seconds, a red square is emitted, and again the next orange square will be ignored and so on and so forth.

Considering the previous example shown with `debounce`:

```typescript
interval(1000)
      .pipe(throttleTime(2000))
      .subscribe({
            next: (value) => console.log(value),
      });
```

this time, some values will be observed with a distance of 2s between each other.

## Buffering

Streams are stateless, meaning that they do not store data emitted from the source, sometimes, however, you will need to cache values before broadcasting them to the Subscribers. The transient data structure where values are stored in RxJs is known as **Buffer**.

Values stored in the buffer are broadcasted to the Observers in arrays, instead of single values as emitted from the source. Moreover, buffering values is useful when dealing with huge quantities of events, such as mouse events, where we need to grouping them and apply some operators instead of working on single values.

### Common buffer operators

There are four common buffer operators in RxJs, each one is based on a specific event like `bufferWhen` and others on common conditions like `bufferCount` and `bufferTime`.

Starting with `buffer` operator, it gathers data emitted by a data source until an observable passed as parameter known as **closing Observable** emits an event, as soon as the event is emitted by the closing Observable, the buffer is flushed and the array is emitted to the attached observers. As we can see from the following figure:

<p align="center">
    <img src="../assets/4. Time/Buffer.png" alt="Buffer Operator" style="width:100%">
</p>

based on an external event represented by the black circle, the input data are group into a single collection and produced to the Observers as a single value. The following code shows how the operator is used in a common scenario:

```typescript
interval(1000)
      .pipe(buffer(interval(2000)))
      .subscribe({
            next: (value) => console.log(`[${value}]`),
      });
```

we are creating a source emitting values each 1s, in the stream a buffer is registred who caches values and emitts them flushing the buffer each 2s, using the Observer `interval(2000)` which emits a value each 2s. Finally, the values are printed to the console in the Observer. The expected result should print each 2s an array containing two elements considering that each element is emitted at 1s ratio. Moreover, what happens if the closing Observer emitts a new value each 500ms? The output will be updated printing each 500ms an empty array, and an array of just one value.

While `buffer` emits values based on a generic condition expressed by the closing Observable, `bufferCount` caches values in the buffer flushing it only once the input size is reached. The working of this operator is shown in the following figure:

Let's consider the following example:

<p align="center">
    <img src="../assets/4. Time/BufferCount.png" alt="Buffer Count Operator" style="width:100%">
</p>

given the input value `3` as soon as the current buffer reaches the given size, a collection of values is emitted, then the current buffer is flushed and a new collection will be emitted containing three values because the input source is closed. 

```typescript
interval(500)
      .pipe(
            bufferCount(5),
            map((values) => values.map((value) => value % users.length)),
            map((indexes) => indexes.map((index) => users[index]?.username)),
      )
      .subscribe({
            next: (names) => console.log(names),
      });
```

what we are going to do is emit values in a rage of 500ms and caching them in a buffer as soon as it reaches the size limit of five elements. Once five elements are in the buffer, we are going to transform the numbers in the buffer in indexes of an array and then on user's usernames. In the end, the final result is printed in the console.

`bufferWhen` cache values as soon as an Observable emits a value similary to `buffer` operator. However, the differnce between the former and the latter is that `bufferWhen` accepts a factory function that creates the Observable, then the values are cached and finally the buffer is flushed. 

<p align="center">
    <img src="../assets/4. Time/BufferWhen.png" alt="Buffer When Operator" style="width:100%">
</p>

considering the input value `valid=true` as an observable emitting a boolean value, as soon as the given observable created by the factory function emits a value, a collection is generated without having a fixed size necessarly. Considering the previous example emitting users' names, we would like to create an Observable that cached values in the buffer and emitts them only after that the former Observable emitts users' names:

```typescript
const bufferCount$ = interval(500).pipe(
      bufferCount(5),
      map((values) => values.map((value) => value % users.length)),
      map((indexes) => indexes.map((index) => users[index]?.username)),
);

bufferCount$.subscribe({
      next: (names) => console.log(`[Buffer Count] - [${names}]`),
});
```

first of all, let's split the Observale definition and assign it in a variable. Now, let's create our observable passing as parameter to the function `bufferWhen` the `bufferCount$` variable:

```typescript
interval(1000)
      .pipe(bufferWhen(() => bufferCount$))
      .subscribe({
            next: (value) => console.log(`[Buffer When] - [${value}]`),
      });
```

Finally, the last operator is `bufferTime` that stores data in the buffer as soon as the time range passed as input is reached. If we would like to store values emitted from the source for an amount of time of 5s, we will implement something like this:

```typescript
interval(1000).pipe(
      bufferTime(5000)
).subscribe({
      next: (value) => console.log(`[Buffer Time] - [${value}]`),
});
```
