# Common Operators

As we mentied before, one of the part of a stream is the set of operators that are applied to an Observable and that transforms the emitted values in a new one whose result is made by the composition of the operators applied to it. The set of operators known as **Pipe** is the result of the application of Functional Programming in RxJs, in fact, each operators is side-effect free, and does not modify the emitted value, while makes a new copy and applies the function in the Pipe.

Thinking to our problems as a set of functions to apply to some values is the core concepts of Reactive Programming. In fact, RxJs provides some useful built-in operators that we can combine to some our problem, some examples are `map`, `filter` from `Array` in JavaScript, we wll see that RxJs contains a set of similar operators.

Digging deeper theoretically, RxJs Operators are high order-functions that does not changes the emitted values from an Observable, rather then returning a new Observable containing the result of the operator's application to that value. Moreover, operators are lazily-evaluated, meaning that no operator is evaluation until a value is emitted thus an Observer is attached to the resulting Observable.

## Mapping values with `map`

`map` is an RxJs operator belonging to the **transform** operators, meaning that changes the value emitted by the Observable applying a function. Moreover, map is **immutable** meaning that it transforms the data without updating the value that is actually emitted by the Observable, and **one-to-one** that is it does not change the size of the original emitted values. The following figure shows briefly how the map operator works in practice:

<p align="center">
    <img src="../assets/3. Common Operators/Map.png" alt="Map Operator" style="width:100%">
</p>

Map is similar to the [**Adapter Design Pattern**](https://en.wikipedia.org/wiki/Adapter_pattern), since it creates a common interface to share data between a source and the corresponding destination, which has incompatible data type. In the sam way, in the previous figure the Observable emitts some circles while the Observer requires to observer triangles, therefore, map interpose itself between them to make to convert circles in triangles such that the Observer now can work correctly.

Finally, let's see the example show in the file [**map.ts**](./map.ts)

- Thanks to [**JSONPlaceholder**](https://jsonplaceholder.typicode.com/) I get a User's Database in the [users.database.ts](../Database/users.database.ts) file. Using the `map` operator, transforms each user in a string like `index [id] [name]` where `index` is the User's position in the database, then creates a new Observer in a separate file named `UserObserver` that prints each user's string and a final report containing: user's number, and the longest string.

The new Observer has been created in the file [`user.observer.ts](./user.observer.ts) and then is attached to the example in the [`map.ts`](map.ts) file. The stream is composed as following:

```typescript
from(users)
      .pipe(map((user: User, index: number) => `${index} - [${user.id}] ${user.name}`))
      .subscribe(new UserObserver(0, ''));
```

`from(users)` is the Observable generated by the set of Users in the database, while the `pipe` creates a new Pipe containing the operator `map`. Notice that in this case, the map function has a second parameter represented by the index of the current element in the string, in fact, the function has two overloads, the first one is the simples with just one parameter, that is the current emitted element, while the latter is the current version shown in the example.

Thus, using the map operator we transform each current user in the corresponding string, and using the Observer we print each emitted value, then once the stream is closed the function `close` is triggered printing the report.

## Filtering with `filter`

While map is a one-to-one operator, **filter** does not return the same input element, while decides who will be keept and who won't be emitted using a function that returns a boolean value. That particular function is also kwnown as **predicate**, meaning that it will predicate a value deciding who pass the test and who not. Therefore, filter updates the size of the emitted string be reducing if it is necessary.

Like the map `operator` the working of the `filter` is shown by the following figure:

<p align="center">
    <img src="../assets/3. Common Operators/Filter.png" alt="Filter Operator" style="width:100%">
</p>

Let's see the example in [**filter.ts**](./filter.ts):

- Creates a stream that checks if a user works for the `Keebler LLC` company, if the user works there, then we can map the user's data in the same string used before:

Let's define the predicate as the function that checks if the user works for the right company:

```typescript
function predicate(user: User) {
      return user.company.name === 'Keebler LLC';
}
```

now let's create the stream using the `filter` and `map` operator, operator and passing to them our predicate:

```typescript
from(users)
      .pipe(
            filter(predicate),
            map((user: User, index: number) => `${index} - [${user.id}] ${user.name}`),
      )
      .subscribe({
            next: (user) => console.log(user),
            error: (err) => console.error(err),
            complete: () => console.log('Stream closed.'),
      });
```

the same result can be achieved (updating the functions in the correct way) by using the `map` operator as the first one, and then the `filter` operator as the second, however, switching the position of the operator causes an incremental usage of resources, because the map operator will be executed for each emitted value, while using `map` as second operator means that it will be triggered only for those values that will not be filtered by `filter`.

## Aggragating elements with `reduce`

Up to this moment, each operator we saw returns a new set of elements, empty or not. The new operator that we are going to introduce does not returns a collection but a single value. Let's consider this common example, we have a set of numbers and we would like to compute the mean of this elements, then we are going to sum each of them and then divide the result for the number of elements. Therefore, the `reduce` operator acts in a similar way, iterating for each element of the collection computing a new single value, however, differently from `map` or `filter`, reduce requires a new mandatory parameter in addiction to the set of elements, that is the **initial value** of the result, back to the mean example, the initial value is `0`.

We can represent `reduce` in the following way:

<p align="center">
    <img src="../assets/3. Common Operators/Reduce.png" alt="Reduce Operator" style="width:100%">
</p>

Let's examinate now the corresponding example, using a different database that contains a set of [`Recipie`](../Database/recipie.interface.ts) in the file [**recipies.database.ts**](../Database/recipies.database.ts):

- We would like to filter all the recipies with the field `difficult` `easy`, moreover we would like to get the mean of all the elements using the `map` operator:

```typescript
from(recipies)
      .pipe(
            filter((recipie) => recipie.difficulty === 'Easy'),
            reduce(
                  (acc, recipie) => {
                        return { sum: acc.sum + recipie.rating, numberOfElements: acc.numberOfElements + 1 };
                  },
                  { sum: 0, numberOfElements: 0 },
            ),
            map((elements) => elements.sum / elements.numberOfElements),
      )
      .subscribe({
            next: (mean) => console.log(mean),
            error: (err) => console.log(err),
            complete: () => console.log('completed'),
      });
```

As we saw `filter` returns only those elements having difficult `Easy`, on the other hand, the most difficult part is to understand how `reduce` is implemented. The problem is to save the number of those elements with the sum of all the ratings, for this reason we would like to use an object there `sum` represents the sum of all the ratings, while `numberOfElements` is the total number of elements and then each value of this object starts from `0`. Now, for each element passing the `filter` predicate takes the rating with `recipie.rating` and then increments the `numberOfElements` by 1, the final result is a single object containing the sum of all rating and the number of recipies. In the end, using `map` we are going to return the mean of all ratings.

## Scanning aggregation of values with `scan`

An interesting variation of `reduce` is `scan`, while `reduce` returns only the final aggregated value, `scan` returns the intermediate aggregated values for all the input elements. Therefore, `scan` returns the same number of elements respect to the input set.

The working of `scan` is shown in this figure, starting from the `reduce` operator, we do not return the final diamond, moreover, we are reurning each intermediate value that is represented by each smaller diamond, whose number is the same of the input elements:

<p align="center">
    <img src="../assets/3. Common Operators/Scan.png" alt="Scan Operator" style="width:100%">
</p>

If we would like to rewrite the previous example using `scan`, we have to replace all the occurrences of `reduce` with `scan`, as shown in the file [**scan.ts**](./scan.ts), however, the output of the Observer would be different since each intermediate value is emitted and shown in the console.

## Additional Operators

There are few additional operators useful for daily tasks, since these operators are not complicated I will not show any diagram or code, while I will describe them briefly:

* `take` is a filtering operator, returning a subset of the input elements whose length is indicated by the parameter. Similar to take `first` and `last` return only the first and the last elements in the input collection.
* `min` and `max` are comparators, returning the minimum and maximum elements in the collection based on the input condition.
* `tap` is the most interesting since is a **side-effect** operator that executes something without altering the input collectio, in fact, it does not returns any value. Moreover, `tap` is useful for example in HTTP call, if you would like to inform the user about the loading progress.

Up to this point, we saw the most common operators in RxJs, now, I would like to make a question. Suppose that we would like to use the same operators of RxJs for an input array, shall we chose to use RxJs or the commonest operator defined in the `Array` class? I made the question because the answer let us to understand how useful is this library, and why should we work harder in understanding how RxJs works. The answer to the question is RxJs, and to explain why, let's see the following example:

```typescript
['Mario', 'Francesco', 'Federica']
      .filter((name) => name.startsWith('F'))
      .map((name) => name.toLocaleUpperCase())
      .forEach((name) => console.log(name)); // FRANCESCO, FEDERICA
```

for each step of the chain, JavaScript creates an intermediate value before apply the function, that is a new copy of the input array `['Mario', 'Francesco', 'Federica']` is created before the execution of the first function, then, after the execution of the `filter` function, a new copy of the input array `['Francesco', 'Federica']` is created, and then after the execution of the `map` function another copy `['FRANCESCO', 'FEDERICA']` is created, and so on and so forth ...

The same example in RxJs is written as follows:

```typescript
from(['Mario', 'Francesco', 'Federica'])
      .pipe(
            filter((name) => name.startsWith('F')),
            map((name) => name.toLocaleUpperCase())
      )
      .subscribe({
            next: (value) => console.log(value),
      })
```

as you can notice, the `forEach` function of the first example takes as argument an array, while the Observable only a single element, this means a single value goes through the pipe without creating intermediate values, that is a smaller set of resources are required in using RxJs, also because the Observer and the operators are light object that do not require an excessive amount of memory.

